#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class SPARQLBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re='#.*?$',
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(SPARQLBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class SPARQLParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re='#.*?$',
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=SPARQLBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(SPARQLParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu()
    def _query_(self):  # noqa
        self._prologue_()
        self.name_last_node('prologue')
        with self._group():
            with self._choice():
                with self._option():
                    self._select_query_()
                with self._option():
                    self._construct_query_()
                with self._option():
                    self._update_query_()
                self._error('no available options')
        self.name_last_node('body')
        self.ast._define(
            ['body', 'prologue'],
            []
        )

    @tatsumasu()
    def _prologue_(self):  # noqa

        def block0():
            with self._choice():
                with self._option():
                    self._base_declaration_()
                with self._option():
                    self._prefix_declaration_()
                self._error('no available options')
        self._closure(block0)

    @tatsumasu('BaseDeclaration')
    def _base_declaration_(self):  # noqa
        self._BASE_()
        self._full_iri_()
        self.name_last_node('iri')
        self.ast._define(
            ['iri'],
            []
        )

    @tatsumasu('PrefixDeclaration')
    def _prefix_declaration_(self):  # noqa
        self._PREFIX_()
        self._prefix_()
        self.name_last_node('prefix')
        self._token(':')
        with self._group():
            with self._choice():
                with self._option():
                    self._relative_iri_()
                with self._option():
                    self._full_iri_()
                self._error('no available options')
        self.name_last_node('iri')
        self.ast._define(
            ['iri', 'prefix'],
            []
        )

    @tatsumasu('SelectQuery')
    def _select_query_(self):  # noqa
        self._select_clause_()
        self.name_last_node('select_clause')
        self._dataset_clause_()
        self.name_last_node('dataset_clause')
        self._where_clause_()
        self.name_last_node('where_clause')
        self._solution_modifier_()
        self.name_last_node('solution_modifier')
        self.ast._define(
            ['dataset_clause', 'select_clause', 'solution_modifier', 'where_clause'],
            []
        )

    @tatsumasu('ConstructQuery')
    def _construct_query_(self):  # noqa
        self._construct_clause_()
        self.name_last_node('construct_clause')
        self._dataset_clause_()
        self.name_last_node('dataset_clause')
        self._where_clause_()
        self.name_last_node('where_clause')
        self.ast._define(
            ['construct_clause', 'dataset_clause', 'where_clause'],
            []
        )

    @tatsumasu('UpdateQuery')
    def _update_query_(self):  # noqa

        def sep1():
            self._token(';')

        def block1():
            self._request_()
        self._positive_gather(block1, sep1)
        self.name_last_node('@')

    @tatsumasu()
    def _request_(self):  # noqa
        with self._optional():
            self._delete_clause_()
        self.name_last_node('delete_clause')
        with self._optional():
            self._insert_clause_()
        self.name_last_node('insert_clause')
        self._where_clause_()
        self.name_last_node('where_clause')
        self.ast._define(
            ['delete_clause', 'insert_clause', 'where_clause'],
            []
        )

    @tatsumasu()
    def _select_clause_(self):  # noqa
        self._select_()
        self._select_group_()
        self.name_last_node('@')

    @tatsumasu()
    def _select_group_(self):  # noqa
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._distinct_()
                    with self._option():
                        self._reduced_()
                    self._error('no available options')
        self.name_last_node('modifier')
        with self._group():
            with self._choice():
                with self._option():
                    self._all_()
                with self._option():

                    def block3():
                        with self._choice():
                            with self._option():
                                self._variable_binding_()
                            with self._option():
                                self._variable_()
                            self._error('no available options')
                    self._positive_closure(block3)
                self._error('no available options')
        self.name_last_node('selection')
        self.ast._define(
            ['modifier', 'selection'],
            []
        )

    @tatsumasu()
    def _construct_clause_(self):  # noqa
        self._construct_()
        self._token('{')
        self._construct_group_()
        self.name_last_node('@')
        self._token('}')

    @tatsumasu()
    def _construct_group_(self):  # noqa

        def block1():
            self._construct_triple_()
        self._closure(block1)
        self.name_last_node('@')

    @tatsumasu()
    def _construct_triple_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_()
                with self._option():
                    self._resource_()
                self._error('no available options')
        self.name_last_node('sub')
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_()
                with self._option():
                    self._resource_()
                self._error('no available options')
        self.name_last_node('pre')
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_()
                with self._option():
                    self._resource_()
                with self._option():
                    self._literal_()
                self._error('no available options')
        self.name_last_node('obj')
        self._token('.')
        self.ast._define(
            ['obj', 'pre', 'sub'],
            []
        )

    @tatsumasu()
    def _dataset_clause_(self):  # noqa

        def block0():
            self._from_()
            self._resource_()
            self.name_last_node('iri')
        self._closure(block0)
        self.ast._define(
            ['iri'],
            []
        )

    @tatsumasu()
    def _insert_clause_(self):  # noqa
        self._insert_()
        self._token('{')
        self._construct_group_()
        self.name_last_node('@')
        self._token('}')

    @tatsumasu()
    def _delete_clause_(self):  # noqa
        self._delete_()
        self._token('{')
        self._construct_group_()
        self.name_last_node('@')
        self._token('}')

    @tatsumasu()
    def _where_clause_(self):  # noqa
        with self._optional():
            self._where_()
        self._group_()
        self.name_last_node('ast')
        self.ast._define(
            ['ast'],
            []
        )

    @tatsumasu('Group')
    def _group_(self):  # noqa
        with self._optional():
            self._graph_()
            self._resource_()
        self._token('{')
        with self._group():
            with self._choice():
                with self._option():
                    self._select_query_()
                with self._option():
                    self._patterns_()
                self._error('no available options')
        self.name_last_node('@')
        self._token('}')

    @tatsumasu()
    def _patterns_(self):  # noqa

        def block0():
            with self._choice():
                with self._option():
                    self._optional_group_()
                with self._option():
                    self._minus_group_()
                with self._option():
                    self._union_group_()
                with self._option():
                    self._group_()
                with self._option():
                    self._triple_()
                with self._option():
                    self._filter_expr_()
                with self._option():
                    self._bind_expr_()
                with self._option():
                    self._data_block_()
                self._error('no available options')
        self._closure(block0)

    @tatsumasu('Triple')
    def _triple_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_()
                with self._option():
                    self._resource_()
                self._error('no available options')
        self.name_last_node('sub')
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_()
                with self._option():
                    self._property_path_()
                self._error('no available options')
        self.name_last_node('pre')
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_()
                with self._option():
                    self._resource_()
                with self._option():
                    self._literal_()
                self._error('no available options')
        self.name_last_node('obj')
        self._token('.')
        self.ast._define(
            ['obj', 'pre', 'sub'],
            []
        )

    @tatsumasu()
    def _solution_modifier_(self):  # noqa
        with self._optional():
            self._groupby_clause_()
        self.name_last_node('groupby_clause')
        with self._optional():
            self._orderby_clause_()
        self.name_last_node('orderby_clause')
        with self._optional():
            self._limit_clause_()
        self.name_last_node('limit_clause')
        self.ast._define(
            ['groupby_clause', 'limit_clause', 'orderby_clause'],
            []
        )

    @tatsumasu()
    def _groupby_clause_(self):  # noqa
        self._groupby_()

        def block1():
            with self._choice():
                with self._option():
                    self._call_()
                with self._option():
                    self._variable_()
                with self._option():
                    self._variable_binding_()
                with self._option():
                    self._token('(')
                    self._expression_()
                    self._token(')')
                self._error('no available options')
        self._positive_closure(block1)
        self.name_last_node('@')

    @tatsumasu()
    def _orderby_clause_(self):  # noqa
        self._orderby_()

        def block1():
            self._orderer_()
        self._closure(block1)
        self.name_last_node('@')

    @tatsumasu()
    def _orderer_(self):  # noqa
        with self._optional():
            with self._choice():
                with self._option():
                    self._asc_()
                with self._option():
                    self._desc_()
                self._error('no available options')
        self.name_last_node('order')
        self._variable_()
        self.name_last_node('variable')
        self.ast._define(
            ['order', 'variable'],
            []
        )

    @tatsumasu()
    def _limit_clause_(self):  # noqa
        self._limit_()
        self._integer_()
        self.name_last_node('@')

    @tatsumasu('Optional')
    def _optional_group_(self):  # noqa
        self._optional_()
        self._group_()
        self.name_last_node('@')

    @tatsumasu('Minus')
    def _minus_group_(self):  # noqa
        self._minus_()
        self._group_()
        self.name_last_node('@')

    @tatsumasu('Union')
    def _union_group_(self):  # noqa
        self._group_()
        self.name_last_node('left')
        self._union_()
        self._group_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'right'],
            []
        )

    @tatsumasu('Filter')
    def _filter_expr_(self):  # noqa
        self._filter_()
        with self._group():
            with self._choice():
                with self._option():
                    self._call_()
                    self.name_last_node('@')
                with self._option():
                    self._token('(')
                    self._expression_()
                    self.name_last_node('@')
                    self._token(')')
                with self._option():
                    self._exists_group_()
                    self.name_last_node('@')
                self._error('no available options')

    @tatsumasu('ExistsGroup')
    def _exists_group_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._exists_()
                with self._option():
                    self._not_exists_()
                self._error('no available options')
        self.name_last_node('predicate')
        self._group_()
        self.name_last_node('group')
        self.ast._define(
            ['group', 'predicate'],
            []
        )

    @tatsumasu('Bind')
    def _bind_expr_(self):  # noqa
        self._bind_()
        self._variable_binding_()
        self.name_last_node('@')

    @tatsumasu()
    def _variable_binding_(self):  # noqa
        self._token('(')
        self._expression_()
        self.name_last_node('expression')
        self._as_()
        self._variable_()
        self.name_last_node('variable')
        self._token(')')
        self.ast._define(
            ['expression', 'variable'],
            []
        )

    @tatsumasu('Data_block')
    def _data_block_(self):  # noqa
        self._values_()
        with self._group():
            with self._choice():
                with self._option():
                    self._one_var_data_()
                with self._option():
                    self._full_data_()
                self._error('no available options')
        self.name_last_node('@')

    @tatsumasu()
    def _one_var_data_(self):  # noqa
        self._variable_()
        self.add_last_node_to_name('variables')
        self._token('{')

        def block2():
            self._single_value_()
        self._closure(block2)
        self.name_last_node('values')
        self._token('}')
        self.ast._define(
            ['values'],
            ['variables']
        )

    @tatsumasu()
    def _full_data_(self):  # noqa
        self._token('(')

        def block1():
            self._variable_()
        self._closure(block1)
        self.name_last_node('variables')
        self._token(')')
        self._token('{')

        def block3():
            self._tuple_()
        self._closure(block3)
        self.name_last_node('values')
        self._token('}')
        self.ast._define(
            ['values', 'variables'],
            []
        )

    @tatsumasu()
    def _tuple_(self):  # noqa
        self._token('(')

        def block1():
            self._data_value_()
        self._closure(block1)
        self.name_last_node('@')
        self._token(')')

    @tatsumasu()
    def _single_value_(self):  # noqa
        self._data_value_()
        self.add_last_node_to_name('@')

    @tatsumasu()
    def _data_value_(self):  # noqa
        with self._choice():
            with self._option():
                self._resource_()
                self.name_last_node('@')
            with self._option():
                self._literal_()
            with self._option():
                self._undef_()
            self._error('no available options')

    @tatsumasu()
    def _property_path_(self):  # noqa

        def sep0():
            self._token('|')

        def block0():
            self._path_sequence_()
        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _path_sequence_(self):  # noqa

        def sep0():
            self._token('/')

        def block0():
            self._path_item_()
        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _path_item_(self):  # noqa
        self._path_inverse_()
        self.name_last_node('inverse')
        with self._group():
            with self._choice():
                with self._option():
                    self._subpath_()
                with self._option():
                    self._resource_()
                self._error('no available options')
        self.name_last_node('term')
        self._path_mod_()
        self.name_last_node('modifier')
        self.ast._define(
            ['inverse', 'modifier', 'term'],
            []
        )

    @tatsumasu()
    def _subpath_(self):  # noqa
        self._token('(')
        self._property_path_()
        self.name_last_node('@')
        self._token(')')

    @tatsumasu()
    def _path_inverse_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('^')
            with self._option():
                self._void()
            self._error('no available options')

    @tatsumasu()
    def _path_mod_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('*')
            with self._option():
                self._token('+')
            with self._option():
                self._void()
            self._error('no available options')

    @tatsumasu()
    def _expression_(self):  # noqa

        def sep0():
            self._token('||')

        def block0():
            self._and_expression_()
        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _and_expression_(self):  # noqa

        def sep0():
            self._token('&&')

        def block0():
            self._comparison_()
        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _comparison_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')
        with self._optional():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('=')
                            with self._option():
                                self._token('!=')
                            with self._option():
                                self._token('<')
                            with self._option():
                                self._token('>')
                            with self._option():
                                self._token('<=')
                            with self._option():
                                self._token('>=')
                            self._error('no available options')
                    self.name_last_node('op')
                    self._arithmetic_expression_()
                    self.name_last_node('right')
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._in_()
                            with self._option():
                                self._notin_()
                            self._error('no available options')
                    self.name_last_node('op')
                    self._expression_list_()
                    self.name_last_node('right')
                self._error('no available options')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _expression_list_(self):  # noqa
        self._token('(')
        with self._group():

            def sep1():
                self._token(',')

            def block1():
                self._expression_()
            self._positive_gather(block1, sep1)
        self.name_last_node('@')
        self._token(')')

    @tatsumasu()
    def _arithmetic_expression_(self):  # noqa
        self._mult_expression_()
        self.name_last_node('left')
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    self._error('no available options')
            self.name_last_node('op')
            self._arithmetic_expression_()
            self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _mult_expression_(self):  # noqa
        self._unary_expression_()
        self.name_last_node('left')
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('*')
                    with self._option():
                        self._token('/')
                    self._error('no available options')
            self.name_last_node('op')
            self._mult_expression_()
            self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _unary_expression_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('!')
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                with self._option():
                    self._void()
                self._error('no available options')
        self.name_last_node('op')
        self._primary_expression_()
        self.name_last_node('expression')
        self.ast._define(
            ['expression', 'op'],
            []
        )

    @tatsumasu()
    def _primary_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._term_()
            with self._option():
                self._call_()
            with self._option():
                self._token('(')
                self._expression_()
                self.name_last_node('@')
                self._token(')')
            self._error('no available options')

    @tatsumasu('Call')
    def _call_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._one_arg_call_()
                with self._option():
                    self._two_arg_call_()
                with self._option():
                    self._aggregate_call_()
                with self._option():
                    self._if_expr_()
                with self._option():
                    self._bound_expr_()
                self._error('no available options')
        self.name_last_node('@')

    @tatsumasu('One_arg_call')
    def _one_arg_call_(self):  # noqa
        self._one_arg_func_()
        self.name_last_node('name')
        self._token('(')
        self._expression_()
        self.name_last_node('argument')
        self._token(')')
        self.ast._define(
            ['argument', 'name'],
            []
        )

    @tatsumasu('Two_arg_call')
    def _two_arg_call_(self):  # noqa
        self._two_arg_func_()
        self.name_last_node('name')
        self._token('(')
        self._expression_()
        self.name_last_node('argument1')
        self._token(',')
        self._expression_()
        self.name_last_node('argument2')
        self._token(')')
        self.ast._define(
            ['argument1', 'argument2', 'name'],
            []
        )

    @tatsumasu('Aggregate_call')
    def _aggregate_call_(self):  # noqa
        self._aggregate_func_()
        self.name_last_node('name')
        self._token('(')
        with self._optional():
            self._distinct_()
            self.name_last_node('distinct')
        self._expression_()
        self.name_last_node('argument')
        self._token(')')
        self.ast._define(
            ['argument', 'distinct', 'name'],
            []
        )

    @tatsumasu('If')
    def _if_expr_(self):  # noqa
        self._if_()
        self._token('(')
        self._expression_()
        self.name_last_node('condition')
        self._token(',')
        self._expression_()
        self.name_last_node('succeed')
        self._token(',')
        self._expression_()
        self.name_last_node('fail')
        self._token(')')
        self.ast._define(
            ['condition', 'fail', 'succeed'],
            []
        )

    @tatsumasu('Bound')
    def _bound_expr_(self):  # noqa
        self._bound_()
        self._token('(')
        self._variable_()
        self.name_last_node('variable')
        self._token(')')
        self.ast._define(
            ['variable'],
            []
        )

    @tatsumasu()
    def _if_(self):  # noqa
        self._pattern('(?i)if')

    @tatsumasu()
    def _bound_(self):  # noqa
        self._pattern('(?i)bound')

    @tatsumasu()
    def _one_arg_func_(self):  # noqa
        self._pattern('(?i)STR|LANG|DATATYPE|IRI|URI|ABS|CEIL|FLOOR|ROUND|STRLEN|UCASE|LCASE|ENCODE_FOR_URI|YEAR|MONTH|DAY|HOURS|MINUTES|SECONDS|TIMEZONE|TZ|MD5|SHA1|SHA256|SHA384|SHA512|isIRI|isURI|isBLANK|isLITERAL|isNUMERIC')

    @tatsumasu()
    def _two_arg_func_(self):  # noqa
        self._pattern('(?i)LANGMATCHES|CONTAINS|STRSTARTS|STRENDS|STRBEFORE|STRAFTER|STRLANG|STRDT|sameTerm')

    @tatsumasu()
    def _aggregate_func_(self):  # noqa
        self._pattern('(?i)COUNT|SUM|MIN|MAX|AVG|SAMPLE')

    @tatsumasu('Term')
    def _term_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._variable_()
                with self._option():
                    self._resource_()
                with self._option():
                    self._literal_()
                self._error('no available options')
        self.name_last_node('@')

    @tatsumasu('Variable')
    def _variable_(self):  # noqa
        self._sigel_()
        self._alphanum_()
        self.name_last_node('name')
        self.ast._define(
            ['name'],
            []
        )

    @tatsumasu('Resource')
    def _resource_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._full_iri_()
                with self._option():
                    self._relative_iri_()
                with self._option():
                    self._prefixed_()
                with self._option():
                    self._rdf_type_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Full_iri')
    def _full_iri_(self):  # noqa
        self._token('<')
        with self._if():
            self._base_()
        self._iri_()
        self.name_last_node('value')
        self._token('>')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Relative_iri')
    def _relative_iri_(self):  # noqa
        self._token('<')
        self._iri_()
        self.name_last_node('value')
        self._token('>')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu()
    def _base_(self):  # noqa
        self._alphanum_()
        self._token('://')

    @tatsumasu('Prefixed')
    def _prefixed_(self):  # noqa
        self._prefix_()
        self.name_last_node('prefix')
        self._token(':')
        self._postfix_()
        self.name_last_node('postfix')
        self.ast._define(
            ['postfix', 'prefix'],
            []
        )

    @tatsumasu()
    def _prefix_(self):  # noqa
        self._alpha_()
        self.name_last_node('@')

    @tatsumasu()
    def _postfix_(self):  # noqa
        self._iri_chars_()
        self.name_last_node('@')

    @tatsumasu('Rdf_type')
    def _rdf_type_(self):  # noqa
        self._token('a')

    @tatsumasu('Literal')
    def _literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._boolean_literal_()
                with self._option():
                    self._numeric_literal_()
                with self._option():
                    self._Rdf_literal_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Boolean_literal')
    def _boolean_literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._true_()
                with self._option():
                    self._false_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Numeric_literal')
    def _numeric_literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._double_()
                with self._option():
                    self._decimal_()
                with self._option():
                    self._integer_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Rdf_literal')
    def _Rdf_literal_(self):  # noqa
        self._String_literal_()
        self.name_last_node('value')
        with self._optional():
            with self._choice():
                with self._option():
                    self._language_tag_()
                    self.name_last_node('language_tag')
                with self._option():
                    with self._group():
                        self._token('^^')
                        self._resource_()
                        self.name_last_node('datatype')
                self._error('no available options')
        self.ast._define(
            ['datatype', 'language_tag', 'value'],
            []
        )

    @tatsumasu()
    def _String_literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._token("'''")
                with self._group():
                    self._pattern('((?!\'\'\')([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token("'''")
            with self._option():
                self._token('"""')
                with self._group():
                    self._pattern('((?!""")([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token('"""')
            with self._option():
                self._token("'")
                with self._group():
                    self._pattern('((?!\')([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token("'")
            with self._option():
                self._token('"')
                with self._group():
                    self._pattern('((?!")([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token('"')
            self._error('no available options')

    @tatsumasu()
    def _language_tag_(self):  # noqa
        self._token('@')
        with self._group():
            self._pattern('[a-zA-Z]+(?:-[a-zA-Z]+)*')
        self.name_last_node('@')

    @tatsumasu('Integer')
    def _integer_(self):  # noqa
        with self._group():
            self._pattern('[0-9]+')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Decimal')
    def _decimal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._pattern('[0-9]*\\.[0-9]+')
                with self._option():
                    with self._group():
                        self._pattern('[0-9]+\\.[0-9]*')
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Double')
    def _double_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._decimal_()
                with self._option():
                    self._integer_()
                self._error('no available options')
        self.name_last_node('base')
        self._pattern('[eE]')
        with self._group():
            with self._optional():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    self._error('no available options')
        self.name_last_node('sign')
        self._integer_()
        self.name_last_node('exponent')
        self.ast._define(
            ['base', 'exponent', 'sign'],
            []
        )

    @tatsumasu('TRUE')
    def _true_(self):  # noqa
        self._pattern('(?i)true')

    @tatsumasu('FALSE')
    def _false_(self):  # noqa
        self._pattern('(?i)false')

    @tatsumasu()
    def _alpha_(self):  # noqa
        self._pattern('[a-zA-Z]*')

    @tatsumasu()
    def _alphanum_(self):  # noqa
        self._pattern('[a-zA-Z0-9_]+')

    @tatsumasu()
    def _iri_chars_(self):  # noqa
        self._pattern('[a-zA-Z]([a-zA-Z0-9_\\-\\.]*[a-zA-Z0-9_])?')

    @tatsumasu()
    def _iri_(self):  # noqa
        self._pattern('[^\\x00-\\x20<>"{}|^`\\\\]*')

    @tatsumasu()
    def _escaped_char_(self):  # noqa
        self._pattern('\\\\[tbnrf"\'\\\\]')

    @tatsumasu()
    def _sigel_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('?')
            with self._option():
                self._token('$')
            self._error('no available options')

    @tatsumasu()
    def _EOL_(self):  # noqa
        self._pattern('[\\n\\r]')

    @tatsumasu()
    def _DQUOTE_(self):  # noqa
        self._pattern('["\\\\]')

    @tatsumasu()
    def _SQUOTE_(self):  # noqa
        self._pattern("['\\\\]")

    @tatsumasu('All')
    def _all_(self):  # noqa
        self._token('*')

    @tatsumasu()
    def _KEYWORD_(self):  # noqa
        with self._choice():
            with self._option():
                self._select_()
            with self._option():
                self._construct_()
            with self._option():
                self._DESCRIBE_()
            with self._option():
                self._where_()
            with self._option():
                self._union_()
            with self._option():
                self._optional_()
            with self._option():
                self._minus_()
            with self._option():
                self._BASE_()
            with self._option():
                self._PREFIX_()
            with self._option():
                self._distinct_()
            with self._option():
                self._reduced_()
            with self._option():
                self._as_()
            with self._option():
                self._from_()
            self._error('no available options')

    @tatsumasu()
    def _select_(self):  # noqa
        self._pattern('(?i)select')

    @tatsumasu()
    def _construct_(self):  # noqa
        self._pattern('(?i)construct')

    @tatsumasu()
    def _DESCRIBE_(self):  # noqa
        self._pattern('(?i)describe')

    @tatsumasu()
    def _where_(self):  # noqa
        self._pattern('(?i)where')

    @tatsumasu()
    def _insert_(self):  # noqa
        self._pattern('(?i)insert')

    @tatsumasu()
    def _delete_(self):  # noqa
        self._pattern('(?i)delete')

    @tatsumasu()
    def _graph_(self):  # noqa
        self._pattern('(?i)graph')

    @tatsumasu()
    def _union_(self):  # noqa
        self._pattern('(?i)union')

    @tatsumasu()
    def _optional_(self):  # noqa
        self._pattern('(?i)optional')

    @tatsumasu()
    def _minus_(self):  # noqa
        self._pattern('(?i)minus')

    @tatsumasu('Exists')
    def _exists_(self):  # noqa
        self._pattern('(?i)exists')

    @tatsumasu('NotExists')
    def _not_exists_(self):  # noqa
        self._pattern('(?i)not\\s+exists')

    @tatsumasu()
    def _groupby_(self):  # noqa
        self._pattern('(?i)group\\s+by')

    @tatsumasu()
    def _orderby_(self):  # noqa
        self._pattern('(?i)order\\s+by')

    @tatsumasu('Asc')
    def _asc_(self):  # noqa
        self._pattern('(?i)asc')

    @tatsumasu('Desc')
    def _desc_(self):  # noqa
        self._pattern('(?i)desc')

    @tatsumasu()
    def _limit_(self):  # noqa
        self._pattern('(?i)limit')

    @tatsumasu()
    def _BASE_(self):  # noqa
        self._pattern('(?i)base')

    @tatsumasu()
    def _PREFIX_(self):  # noqa
        self._pattern('(?i)prefix')

    @tatsumasu()
    def _values_(self):  # noqa
        self._pattern('(?i)values')

    @tatsumasu('Undef')
    def _undef_(self):  # noqa
        self._pattern('(?i)undef')

    @tatsumasu('Distinct')
    def _distinct_(self):  # noqa
        self._pattern('(?i)distinct')

    @tatsumasu('Reduced')
    def _reduced_(self):  # noqa
        self._pattern('(?i)reduced')

    @tatsumasu('In')
    def _in_(self):  # noqa
        self._pattern('(?i)in')

    @tatsumasu('Notin')
    def _notin_(self):  # noqa
        self._pattern('(?i)not\\s+in')

    @tatsumasu()
    def _as_(self):  # noqa
        self._pattern('(?i)as')

    @tatsumasu()
    def _from_(self):  # noqa
        self._pattern('(?i)from')

    @tatsumasu()
    def _bind_(self):  # noqa
        self._pattern('(?i)bind')

    @tatsumasu()
    def _filter_(self):  # noqa
        self._pattern('(?i)filter')


class SPARQLSemantics(object):
    def query(self, ast):  # noqa
        return ast

    def prologue(self, ast):  # noqa
        return ast

    def base_declaration(self, ast):  # noqa
        return ast

    def prefix_declaration(self, ast):  # noqa
        return ast

    def select_query(self, ast):  # noqa
        return ast

    def construct_query(self, ast):  # noqa
        return ast

    def update_query(self, ast):  # noqa
        return ast

    def request(self, ast):  # noqa
        return ast

    def select_clause(self, ast):  # noqa
        return ast

    def select_group(self, ast):  # noqa
        return ast

    def construct_clause(self, ast):  # noqa
        return ast

    def construct_group(self, ast):  # noqa
        return ast

    def construct_triple(self, ast):  # noqa
        return ast

    def dataset_clause(self, ast):  # noqa
        return ast

    def insert_clause(self, ast):  # noqa
        return ast

    def delete_clause(self, ast):  # noqa
        return ast

    def where_clause(self, ast):  # noqa
        return ast

    def group(self, ast):  # noqa
        return ast

    def patterns(self, ast):  # noqa
        return ast

    def triple(self, ast):  # noqa
        return ast

    def solution_modifier(self, ast):  # noqa
        return ast

    def groupby_clause(self, ast):  # noqa
        return ast

    def orderby_clause(self, ast):  # noqa
        return ast

    def orderer(self, ast):  # noqa
        return ast

    def limit_clause(self, ast):  # noqa
        return ast

    def optional_group(self, ast):  # noqa
        return ast

    def minus_group(self, ast):  # noqa
        return ast

    def union_group(self, ast):  # noqa
        return ast

    def filter_expr(self, ast):  # noqa
        return ast

    def exists_group(self, ast):  # noqa
        return ast

    def bind_expr(self, ast):  # noqa
        return ast

    def variable_binding(self, ast):  # noqa
        return ast

    def data_block(self, ast):  # noqa
        return ast

    def one_var_data(self, ast):  # noqa
        return ast

    def full_data(self, ast):  # noqa
        return ast

    def tuple(self, ast):  # noqa
        return ast

    def single_value(self, ast):  # noqa
        return ast

    def data_value(self, ast):  # noqa
        return ast

    def property_path(self, ast):  # noqa
        return ast

    def path_sequence(self, ast):  # noqa
        return ast

    def path_item(self, ast):  # noqa
        return ast

    def subpath(self, ast):  # noqa
        return ast

    def path_inverse(self, ast):  # noqa
        return ast

    def path_mod(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def and_expression(self, ast):  # noqa
        return ast

    def comparison(self, ast):  # noqa
        return ast

    def expression_list(self, ast):  # noqa
        return ast

    def arithmetic_expression(self, ast):  # noqa
        return ast

    def mult_expression(self, ast):  # noqa
        return ast

    def unary_expression(self, ast):  # noqa
        return ast

    def primary_expression(self, ast):  # noqa
        return ast

    def call(self, ast):  # noqa
        return ast

    def one_arg_call(self, ast):  # noqa
        return ast

    def two_arg_call(self, ast):  # noqa
        return ast

    def aggregate_call(self, ast):  # noqa
        return ast

    def if_expr(self, ast):  # noqa
        return ast

    def bound_expr(self, ast):  # noqa
        return ast

    def if_(self, ast):  # noqa
        return ast

    def bound(self, ast):  # noqa
        return ast

    def one_arg_func(self, ast):  # noqa
        return ast

    def two_arg_func(self, ast):  # noqa
        return ast

    def aggregate_func(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def variable(self, ast):  # noqa
        return ast

    def resource(self, ast):  # noqa
        return ast

    def full_iri(self, ast):  # noqa
        return ast

    def relative_iri(self, ast):  # noqa
        return ast

    def base(self, ast):  # noqa
        return ast

    def prefixed(self, ast):  # noqa
        return ast

    def prefix(self, ast):  # noqa
        return ast

    def postfix(self, ast):  # noqa
        return ast

    def rdf_type(self, ast):  # noqa
        return ast

    def literal(self, ast):  # noqa
        return ast

    def boolean_literal(self, ast):  # noqa
        return ast

    def numeric_literal(self, ast):  # noqa
        return ast

    def Rdf_literal(self, ast):  # noqa
        return ast

    def String_literal(self, ast):  # noqa
        return ast

    def language_tag(self, ast):  # noqa
        return ast

    def integer(self, ast):  # noqa
        return ast

    def decimal(self, ast):  # noqa
        return ast

    def double(self, ast):  # noqa
        return ast

    def true(self, ast):  # noqa
        return ast

    def false(self, ast):  # noqa
        return ast

    def alpha(self, ast):  # noqa
        return ast

    def alphanum(self, ast):  # noqa
        return ast

    def iri_chars(self, ast):  # noqa
        return ast

    def iri(self, ast):  # noqa
        return ast

    def escaped_char(self, ast):  # noqa
        return ast

    def sigel(self, ast):  # noqa
        return ast

    def EOL(self, ast):  # noqa
        return ast

    def DQUOTE(self, ast):  # noqa
        return ast

    def SQUOTE(self, ast):  # noqa
        return ast

    def all(self, ast):  # noqa
        return ast

    def KEYWORD(self, ast):  # noqa
        return ast

    def select(self, ast):  # noqa
        return ast

    def construct(self, ast):  # noqa
        return ast

    def DESCRIBE(self, ast):  # noqa
        return ast

    def where(self, ast):  # noqa
        return ast

    def insert(self, ast):  # noqa
        return ast

    def delete(self, ast):  # noqa
        return ast

    def graph(self, ast):  # noqa
        return ast

    def union(self, ast):  # noqa
        return ast

    def optional(self, ast):  # noqa
        return ast

    def minus(self, ast):  # noqa
        return ast

    def exists(self, ast):  # noqa
        return ast

    def not_exists(self, ast):  # noqa
        return ast

    def groupby(self, ast):  # noqa
        return ast

    def orderby(self, ast):  # noqa
        return ast

    def asc(self, ast):  # noqa
        return ast

    def desc(self, ast):  # noqa
        return ast

    def limit(self, ast):  # noqa
        return ast

    def BASE(self, ast):  # noqa
        return ast

    def PREFIX(self, ast):  # noqa
        return ast

    def values(self, ast):  # noqa
        return ast

    def undef(self, ast):  # noqa
        return ast

    def distinct(self, ast):  # noqa
        return ast

    def reduced(self, ast):  # noqa
        return ast

    def in_(self, ast):  # noqa
        return ast

    def notin(self, ast):  # noqa
        return ast

    def as_(self, ast):  # noqa
        return ast

    def from_(self, ast):  # noqa
        return ast

    def bind(self, ast):  # noqa
        return ast

    def filter(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'query'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = SPARQLParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, SPARQLParser, name='SPARQL')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()


class GFDSLBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(GFDSLBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class GFDSLParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=GFDSLBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(GFDSLParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu()
    def _query_(self):  # noqa
        self._patterns_()
        self.name_last_node('@')

    @tatsumasu()
    def _patterns_(self):  # noqa

        def sep0():
            self._token(';')

        def block0():
            self._triple_()
        self._gather(block0, sep0)

    @tatsumasu('Triple')
    def _triple_(self):  # noqa
        self._token('(')
        with self._optional():
            self._nvariable_()
        self.name_last_node('sub')
        self._token(')-[')
        with self._optional():
            self._nvariable_()
        self.name_last_node('pre')
        self._token(']->(')
        with self._optional():
            self._nvariable_()
        self.name_last_node('obj')
        self._token(')')
        self.ast._define(
            ['obj', 'pre', 'sub'],
            []
        )

    @tatsumasu('Variable')
    def _nvariable_(self):  # noqa
        self._pattern('[a-zA-Z][a-zA-Z0-9_]*')
        self.name_last_node('name')
        self.ast._define(
            ['name'],
            []
        )

    @tatsumasu()
    def _expression_(self):  # noqa

        def sep0():
            self._token('||')

        def block0():
            self._and_expression_()
        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _and_expression_(self):  # noqa

        def sep0():
            self._token('&&')

        def block0():
            self._comparison_()
        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _comparison_(self):  # noqa
        self._arithmetic_expression_()
        self.name_last_node('left')
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('=')
                    with self._option():
                        self._token('!=')
                    with self._option():
                        self._token('<')
                    with self._option():
                        self._token('>')
                    with self._option():
                        self._token('<=')
                    with self._option():
                        self._token('>=')
                    self._error('no available options')
            self.name_last_node('op')
            self._arithmetic_expression_()
            self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _arithmetic_expression_(self):  # noqa
        self._mult_expression_()
        self.name_last_node('left')
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    self._error('no available options')
            self.name_last_node('op')
            self._arithmetic_expression_()
            self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _mult_expression_(self):  # noqa
        self._unary_expression_()
        self.name_last_node('left')
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('*')
                    with self._option():
                        self._token('/')
                    self._error('no available options')
            self.name_last_node('op')
            self._mult_expression_()
            self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _unary_expression_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('!')
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                with self._option():
                    self._void()
                self._error('no available options')
        self.name_last_node('op')
        self._primary_expression_()
        self.name_last_node('expression')
        self.ast._define(
            ['expression', 'op'],
            []
        )

    @tatsumasu()
    def _primary_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._call_()
            with self._option():
                self._term_()
            with self._option():
                self._token('(')
                self._expression_()
                self.name_last_node('@')
                self._token(')')
            self._error('no available options')

    @tatsumasu('Call')
    def _call_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._one_arg_call_()
                with self._option():
                    self._two_arg_call_()
                with self._option():
                    self._aggregate_call_()
                with self._option():
                    self._if_expr_()
                with self._option():
                    self._bound_expr_()
                self._error('no available options')
        self.name_last_node('@')

    @tatsumasu('One_arg_call')
    def _one_arg_call_(self):  # noqa
        self._one_arg_func_()
        self.name_last_node('name')
        self._token('(')
        self._expression_()
        self.name_last_node('argument')
        self._token(')')
        self.ast._define(
            ['argument', 'name'],
            []
        )

    @tatsumasu('Two_arg_call')
    def _two_arg_call_(self):  # noqa
        self._two_arg_func_()
        self.name_last_node('name')
        self._token('(')
        self._expression_()
        self.name_last_node('argument1')
        self._token(',')
        self._expression_()
        self.name_last_node('argument2')
        self._token(')')
        self.ast._define(
            ['argument1', 'argument2', 'name'],
            []
        )

    @tatsumasu('Aggregate_call')
    def _aggregate_call_(self):  # noqa
        self._aggregate_func_()
        self.name_last_node('name')
        self._token('(')
        self._expression_()
        self.name_last_node('argument')
        self._token(')')
        self.ast._define(
            ['argument', 'name'],
            []
        )

    @tatsumasu('If')
    def _if_expr_(self):  # noqa
        self._if_()
        self._token('(')
        self._expression_()
        self.name_last_node('condition')
        self._token(',')
        self._expression_()
        self.name_last_node('succeed')
        self._token(',')
        self._expression_()
        self.name_last_node('fail')
        self._token(')')
        self.ast._define(
            ['condition', 'fail', 'succeed'],
            []
        )

    @tatsumasu('Bound')
    def _bound_expr_(self):  # noqa
        self._bound_()
        self._token('(')
        self._nvariable_()
        self.name_last_node('variable')
        self._token(')')
        self.ast._define(
            ['variable'],
            []
        )

    @tatsumasu()
    def _if_(self):  # noqa
        self._pattern('(?i)if')

    @tatsumasu()
    def _bound_(self):  # noqa
        self._pattern('(?i)bound')

    @tatsumasu()
    def _one_arg_func_(self):  # noqa
        self._pattern('(?i)STR|LANG|DATATYPE|IRI|URI|ABS|CEIL|FLOOR|ROUND|STRLEN|UCASE|LCASE|ENCODE_FOR_URI|YEAR|MONTH|DAY|HOURS|MINUTES|SECONDS|TIMEZONE|TZ|MD5|SHA1|SHA256|SHA384|SHA512|isIRI|isURI|isBLANK|isLITERAL|isNUMERIC')

    @tatsumasu()
    def _two_arg_func_(self):  # noqa
        self._pattern('(?i)LANGMATCHES|CONTAINS|STRSTARTS|STRENDS|STRBEFORE|STRAFTER|STRLANG|STRDT|sameTerm')

    @tatsumasu()
    def _aggregate_func_(self):  # noqa
        self._pattern('(?i)COUNT|SUM|MIN|MAX|AVG|SAMPLE')

    @tatsumasu('Term')
    def _term_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._literal_()
                with self._option():
                    self._resource_()
                with self._option():
                    self._nvariable_()
                self._error('no available options')
        self.name_last_node('@')

    @tatsumasu('Resource')
    def _resource_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._relative_iri_()
                with self._option():
                    self._full_iri_()
                with self._option():
                    self._prefixed_()
                with self._option():
                    self._rdf_type_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Full_iri')
    def _full_iri_(self):  # noqa
        self._token('<')
        with self._if():
            self._base_()
        self._iri_()
        self.name_last_node('value')
        self._token('>')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Relative_iri')
    def _relative_iri_(self):  # noqa
        self._token('<')
        self._iri_()
        self.name_last_node('value')
        self._token('>')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu()
    def _base_(self):  # noqa
        self._alphanum_()
        self._token('://')

    @tatsumasu('Prefixed')
    def _prefixed_(self):  # noqa
        self._prefix_()
        self.name_last_node('prefix')
        self._token(':')
        self._postfix_()
        self.name_last_node('postfix')
        self.ast._define(
            ['postfix', 'prefix'],
            []
        )

    @tatsumasu()
    def _prefix_(self):  # noqa
        self._alpha_()
        self.name_last_node('@')

    @tatsumasu()
    def _postfix_(self):  # noqa
        self._alphanum_()
        self.name_last_node('@')

    @tatsumasu('Rdf_type')
    def _rdf_type_(self):  # noqa
        self._token('a')

    @tatsumasu('Literal')
    def _literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._boolean_literal_()
                with self._option():
                    self._numeric_literal_()
                with self._option():
                    self._Rdf_literal_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Boolean_literal')
    def _boolean_literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._true_()
                with self._option():
                    self._false_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Numeric_literal')
    def _numeric_literal_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._DOUBLE_()
                with self._option():
                    self._DECIMAL_()
                with self._option():
                    self._INTEGER_()
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Rdf_literal')
    def _Rdf_literal_(self):  # noqa
        self._String_literal_()
        self.name_last_node('value')
        with self._optional():
            with self._choice():
                with self._option():
                    self._language_tag_()
                    self.name_last_node('language_tag')
                with self._option():
                    with self._group():
                        self._token('^^')
                        self._resource_()
                        self.name_last_node('datatype')
                self._error('no available options')
        self.ast._define(
            ['datatype', 'language_tag', 'value'],
            []
        )

    @tatsumasu()
    def _String_literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._token("'''")
                with self._group():
                    self._pattern('((?!\'\'\')([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token("'''")
            with self._option():
                self._token('"""')
                with self._group():
                    self._pattern('((?!""")([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token('"""')
            with self._option():
                self._token("'")
                with self._group():
                    self._pattern('((?!\')([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token("'")
            with self._option():
                self._token('"')
                with self._group():
                    self._pattern('((?!")([^\\\\]|\\\\[tbnrf"\'\\\\]))*')
                self.name_last_node('@')
                self._token('"')
            self._error('no available options')

    @tatsumasu()
    def _language_tag_(self):  # noqa
        self._token('@')
        with self._group():
            self._pattern('[a-zA-Z]+(?:-[a-zA-Z]+)*')
        self.name_last_node('@')

    @tatsumasu('Integer')
    def _INTEGER_(self):  # noqa
        with self._group():
            self._pattern('[0-9]+')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Decimal')
    def _DECIMAL_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._pattern('[0-9]*\\.[0-9]+')
                with self._option():
                    with self._group():
                        self._pattern('[0-9]+\\.[0-9]*')
                self._error('no available options')
        self.name_last_node('value')
        self.ast._define(
            ['value'],
            []
        )

    @tatsumasu('Double')
    def _DOUBLE_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._DECIMAL_()
                with self._option():
                    self._INTEGER_()
                self._error('no available options')
        self.name_last_node('base')
        self._pattern('[eE]')
        with self._group():
            with self._optional():
                with self._choice():
                    with self._option():
                        self._token('+')
                    with self._option():
                        self._token('-')
                    self._error('no available options')
        self.name_last_node('sign')
        self._INTEGER_()
        self.name_last_node('exponent')
        self.ast._define(
            ['base', 'exponent', 'sign'],
            []
        )

    @tatsumasu('TRUE')
    def _true_(self):  # noqa
        self._pattern('(?i)true')

    @tatsumasu('FALSE')
    def _false_(self):  # noqa
        self._pattern('(?i)false')

    @tatsumasu()
    def _alpha_(self):  # noqa
        self._pattern('[a-zA-Z]*')

    @tatsumasu()
    def _alphanum_(self):  # noqa
        self._pattern('[a-zA-Z0-9_]+')

    @tatsumasu()
    def _iri_(self):  # noqa
        self._pattern('[^\\x00-\\x20<>"{}|^`\\\\]*')

    @tatsumasu()
    def _escaped_char_(self):  # noqa
        self._pattern('\\\\[tbnrf"\'\\\\]')


class GFDSLSemantics(object):
    def query(self, ast):  # noqa
        return ast

    def patterns(self, ast):  # noqa
        return ast

    def triple(self, ast):  # noqa
        return ast

    def nvariable(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def and_expression(self, ast):  # noqa
        return ast

    def comparison(self, ast):  # noqa
        return ast

    def arithmetic_expression(self, ast):  # noqa
        return ast

    def mult_expression(self, ast):  # noqa
        return ast

    def unary_expression(self, ast):  # noqa
        return ast

    def primary_expression(self, ast):  # noqa
        return ast

    def call(self, ast):  # noqa
        return ast

    def one_arg_call(self, ast):  # noqa
        return ast

    def two_arg_call(self, ast):  # noqa
        return ast

    def aggregate_call(self, ast):  # noqa
        return ast

    def if_expr(self, ast):  # noqa
        return ast

    def bound_expr(self, ast):  # noqa
        return ast

    def if_(self, ast):  # noqa
        return ast

    def bound(self, ast):  # noqa
        return ast

    def one_arg_func(self, ast):  # noqa
        return ast

    def two_arg_func(self, ast):  # noqa
        return ast

    def aggregate_func(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def resource(self, ast):  # noqa
        return ast

    def full_iri(self, ast):  # noqa
        return ast

    def relative_iri(self, ast):  # noqa
        return ast

    def base(self, ast):  # noqa
        return ast

    def prefixed(self, ast):  # noqa
        return ast

    def prefix(self, ast):  # noqa
        return ast

    def postfix(self, ast):  # noqa
        return ast

    def rdf_type(self, ast):  # noqa
        return ast

    def literal(self, ast):  # noqa
        return ast

    def boolean_literal(self, ast):  # noqa
        return ast

    def numeric_literal(self, ast):  # noqa
        return ast

    def Rdf_literal(self, ast):  # noqa
        return ast

    def String_literal(self, ast):  # noqa
        return ast

    def language_tag(self, ast):  # noqa
        return ast

    def INTEGER(self, ast):  # noqa
        return ast

    def DECIMAL(self, ast):  # noqa
        return ast

    def DOUBLE(self, ast):  # noqa
        return ast

    def true(self, ast):  # noqa
        return ast

    def false(self, ast):  # noqa
        return ast

    def alpha(self, ast):  # noqa
        return ast

    def alphanum(self, ast):  # noqa
        return ast

    def iri(self, ast):  # noqa
        return ast

    def escaped_char(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'query'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = GFDSLParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, GFDSLParser, name='GFDSL')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
